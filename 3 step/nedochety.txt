J16	Логирование
Познакомится со сравнительной характеристикой разных библиотек и уметь рассказать о +/- той или иной
неправильно рассказал о иерархии логгеров, но в целом ок
Разобраться в отличиях создания логгера просто по строке и по имени класса: каким должен быть формат строки для имени и как это имя учитывается в конфигурировании.
Разобраться со способами как можно делать ленивый расчет аргументов строки сообщения лога, если данный уровень логгирования отключен.
Разобраться с преимуществами использования библиотеки SLF4J в качестве фасада для логирования. Разобраться в чем будет разница создания логгера по классу или просто по строке.
Logback layout.
Разобраться что такое Encoder, Layout в Logback.
Посмотреть, как можно "прятать" трудоемкий расчет параметров для сообщения лога, если текущий уровень логирования может быть отключен
Разобраться лучше зачем нужны Encoders и Filters в Logback.
Разобраться лучше какие преимущества дают системы логирования.
Разобраться с производительностью логирования. Логирование в многопоточных приложениях.
Почитать про булевские методы для проверки уровня логирования.
Посмотреть, как включать или выключать логгирование на уровне некоторых пакетов/классов. Также разобраться с использование LoggerFactory и какие есть способы получения объекта Logger. Посмотреть как делать "ленивое" логирование, учитывая что данный уровень логгирования может быть отключен.
Разобраться с Filters.
Пробел в знаниях по фильтрам. В остальном - хорошо.
Пробел в знаниях по фильтрам. В остальном - хороший уровень, обсудили потенциальные проблемы некорректного логгирования (интенсивные операции с диском, логгирование критических данных, расходование дискового пространства)
Разобраться с Filter в log4j.
Точно не понимает необходимость использования логеров в т.ч. в многопоточных приложениях.
Разобраться с причинами настройки разных уровней дебага и в каких случаях отладка приложения без логера невозможна.
Лучше разобраться с наследованием логирования. Разобраться с аспектами производительности приложения при логировании.
Подумать над всеми преимущeствами, которые даёт использование логеров.



J18	Time API (Java 8)
Разобраться что и где применять: Instant или ZonedDateTime, а так же плюсы и минусы. Рассмотреть как конвертировать типы из нового API в старое и обратно
Разобраться лучше с переводом дат из нового в старое API и наоборот, что такое ChronoUnit.
Разобраться с различием старой и новой даты и как перевести одно в другое
Разобраться лучше с интерфейсом Temporal.
Разобраться с переводом дат между старым и новым API.
Побольше попрактиковать с использовании классов и методов из TimeAPI.
Стоит изучить, как делать преобразования между старым java.util.Date и новыми LocalDate или LocalDateTime (в обе стороны).
И лучше еще побольше попрактиковаться в использовании java.time
Разобраться чуть лучше с работой с DateTimeFormatter.
Разобраться с Era, проблемами Time API 8
Нет понимания как работает Instant, Clock
Разобраться лучше зачем нужен класс Clock.
Плохо понимает преимущества использования Instant, Clock, затруднения с TemporalAccessor
Разобраться лучше зачем нужен Instant и ZoneId.
Разобраться лучше с отличиями между старым и новым API, разобраться с java.time.Clock, какие классы реализуют интерфейс Temporal.
Разобраться с java.time.Clock, лучше разобраться зачем был разработан новый time api и какие проблемы решает.
Разобраться лучше как переводить даты между старым и новым API.
Пробелы в знаниях по преобразованию объектов разных типов и некоторым конкретным методам API.
Разобраться с TimeZone, Clock их преимущества по сравнению с Calendar, MonthDay, Year, YearMonth, DateTimeFormatter
Разобраться подробнее с отличиями старого и нового API, какие новые возможности у Clock, Duration, Period и DateTimeFormatter.
Хорошие знания истории вопроса работы с датой и временем. Незначительные недочёты при рассмотрении предложенных практических примеров (учёт часовых поясов при обработке дат и времени создания сообщений в соцсети, проверка разницы между двумя датами)
Разобраться с фундаментальными проблемами java.util.Date и необходимостью появления java.time.Instant. Разобраться с пакетом java.time.chrono.
Разобраться зачем понадобился Instant, разобраться как можно преобразовывать даты между различными календарями.
Посмотреть методы сравнения LocalDate с другой датой.
Частично прошлые пробелы по методам использования были устранены, а частично еще остались пробелы по другим спрашиваемым методам (например, методы получения LocalDateTime из LocalDate) Также еще раз посмотреть алгоритм парсинга и форматирования дат из строки и обратно.
Разобраться как создавать LocalDate, LocalDateTime на какую-либо конкретную дату, и какие есть методы для проведения операций над датами, как ими пользоваться, как переводить даты из старого в новое API и наоборот.
Знание классов и их применение только на легком теоретическом уровне. А методы по созданию или манипуляциями над этими объектами не знает даже на приближенном уровне.
Затруднения с instant.
Разобраться зачем нужен Instant, разобраться как переводить даты из старого в новое АПИ и наоборот.
Небольшие пробелы в знаниях по манипуляциям с Temporal, Duration.of(...). В остальном - хорошо.
Разобраться с Clock, DateTimeFormatter. Не смог написать простую задачку по получению следующего понедельника.
Разобраться как получить дату следующего понедельника от текущей даты с помощью Time API, с классом Clock и подробнее почитать про форматтер дат.




J19	Пакет java.nio.
Разобраться с не блокирующимся вводом-выводом и причем здесь Channels, интерфейсом Watchable
Разобраться с блокировкой и производительностью при сравнени io VS nio
Лучше разобраться с WatchService, FileVisitor
Разобраться лучше с WatchService, EventObject и FileVisitor.
Посмотреть методы Files для чтения и записи в файл.
Для работы с каналами для записи в файл уже смог написать пример кодом. Описание работы через WatchService давал устно. На слух начало было похоже, но дальнейшие действия для получения изменений уже были не совсем так. Очень и очень скудно по методам утилитарного класса Files
Разобраться в чем отличие File и Files, разобраться, что можно делать с помощью утилитного класса Paths, разобраться как на практике использовать Channel, чтобы записать какие-то данные в файл.
Разобраться что blocking/non-blocking здесь относится к потокам выполнения, а не к ресурсам. Работа с каналами и буфферами только на теоретическом уровне. Как это кодом выглядит он не смог написать/рассказать. FileVisitor - нормально. Единственное, что ошибся с с тем, метод чего нужно вызывать для обхода. WatchService - почти никак.
Местами путаница с названиями методов Path, Files и Paths. Пробел в понимании завершения обхода дерева FileVisitor. Пробел в понимании того, что объект Path не обязательно соответствует физически существующему объекту файловой системы.
FileVisitor - плохо понимает WatchService - плохо понимает Класс Path. Утилитарные классы Files и Paths. - не помнит как создать экземпляр Path



J22	Java Concurrency
Разобраться лучше с RunnableFuture.
Поразбираться в логике работы Semaphore, CyclicBarrier и CountDownLatch. Сравнить поведение. В остальном вопрос расскрыт хорошо!
Подробные объяснения, виден хороший уровень понимания вопроса. Рекомендую почитать подробнее про CyclicBarrier




J23	Сервлеты/JSP
затруднения с: чтение body/вовзрат ответа, не знает где хранится http сессия, напутала про синтаксис jstl, как подключать кастомные тэги на странице но в целом ок
Поразбираться с JSP: возможности скриплет, выражений и объявление полей/методов. А также получше разобраться с извлечение значений из различных источников на стороне JSP (или же пробрасывание данных в JSP) без сервлетов.
Разобраться лучше с созданием сессии, разобраться лучше зачем нужны фильтры.
Разобраться с фильтрами: зачем они нужны и какие стандартные варианты их использовать. А также как фильтрами обрабатывать как запрос, так и ответ.
Разобраться когда инициализируется сервлет, посмотреть реализацию HttpServlet, JSP: разница между разными типами include, scope JSP, назначение тэга out. библиотека JSTL слабо
Разобраться лучше когда происходит init сервлета, разобраться в чем разница между директивой include и jsp:include, разобраться со скоупами jsp в чем разница со скоупами сервлетов, разобраться с возможностями тэга c:out.
Разобраться лучше, когда создается HttpSession.
Почти все прошлый пробелы были полностью устранены.
в целом ок, но немного напутал местами: как относятся потоки и сервлеты, как сделать через скриплеты итерацию (пример вывод таблицы), не смог объяснить что "под капотом" у таглиба (в частности jstl)
Сервлеты - хорошо. Разобраться как и когда создается сессия, а также как удалять сессию. Посмотреть для чего необходима сессия и какие именно данные обычно храняться.
JSP: разобраться с синтаксисом на примере вывода некоторого набора элементов в цикле через скриплет. Посмотреть директивы, их предназначение и синтаксис. Посмотреть как работают теги из JSTL или любые другие "кастомные" теги. Посмотреть EL (операторы и зарезервированные слова)
Разобраться в предназначении фильтров для обработки как запросов, так и ответов через них.



B5	Оптимизация производительности
Лучше разобраться с составными индексами.
Разобраться лучше с составными индексами, как они работают.
теоретические знания есть, немного хромает практическое применение, к тем же индексам пришлось подталкивать
Разобраться с принципом создания составного индекса, почитать дополнительно про команду EXPLAIN.
Посмотреть влияет ли порядок индексов и вывод EXPLAIN
Разобраться с созданием индексных выражений.
Разобраться с критериями создания и использованием составных индексов в запросе.
Разобраться влияет ли порядок условий в запросе на выполнение этого запросу СУБД и как создавать составные индексы по каким правилам, разобраться с использованием составных индексов при частичном совпадении колонок.
Разобраться с использованием индекса при частичном совпадении индекса с выражением в запросе
Умеет использовать explain, может выделить индексы. Рекомендуется уделить внимание деталям (составные индексы, в какой момент создавать индексы, случаи применения индекса - не только where)
Пробел в понимании особенностей использования составных индексов, кардинальности индексов
Разобраться как в составном индексе определять порядок колонок.
Теоретическая часть изучена нормально. Были некоторые замечания по практической части. Рекомендую детальнее изучить планы выполнения запроса (Execution Plan) и типы чтения в запросах с предикатами при наличии индексов.
Пробел в знаниях по задействованию индексов различными SQL-конструкциями, по порядку столбцов в составных индексах.
Теоретическую часть изучил хорошо. Но есть проблемы с пониманием как применять теоретические знания на практике. Для закрепления материала предлагаю с моей помощью проделать практические упражнения по оптимизации запросов на проекте art-sport.
Разобраться в отличиях и преимуществах различных типов индексов между собой. Разобраться получше с типами операций в плане запроса и разницей работы и производительности этих типов.
Основные понятия не раскрыты.
Изучить темы:
    Query Processing Architecture Guide https://docs.microsoft.com/ru-ru/sql/relational-databases/query-processing-architecture-guide
    SQL Server join operators https://www.youtube.com/watch?v=QV5CYsjkzqw
    Showplan Logical and Physical Operators Reference https://docs.microsoft.com/ru-ru/sql/relational-databases/showplan-logical-and-physical-operators-reference
    Hints (Transact-SQL) https://docs.microsoft.com/ru-ru/sql/t-sql/queries/hints-transact-sql
    SQL Server Statistics https://www.sqlshack.com/sql-server-statistics-and-how-to-perform-update-statistics-in-sql/ https://docs.microsoft.com/ru-ru/sql/t-sql/statements/update-statistics-transact-sql
    Index fragmentation and rebuild https://docs.microsoft.com/ru-ru/sql/relational-databases/indexes/reorganize-and-rebuild-indexes
Поразбираться с оптимизацией view, созданием многоколончатых индексов.
Разобраться в каком порядке нужно добавлять колонки в индекс с несколькими колонками
Проблемы с порядком столбцов в запросах при использовании составных индексов. В остальном - хорошо.
Поупражняться в чтении планов с целью оптимизации разных запросов.
заминка с профилированием медленных запросов, cardinality, первичный ключ (индексация ключа), constrains
Разобраться как выбрать запросы для оптимизации. Разобраться со стоимостью запроса, количеством записей для чтения и типом чтения данных (физический/логический). Разобраться с индексацией первичного и внешнего ключа. Разобраться со структурой индексов, типов данных в узлах, хэширование.
Разобраться где взять запросы для оптимизации и как из этой массы выбрать те которые требуют оптимизации в первую очередь. Разобраться cardinality и ее роль в написании индексов.
разобраться как найти запросы, которые нужно оптимизировать, разобраться как правильно создавать составные индексы в зависимости от cardinality




W5	Продвинутый CSS
W7	Продвинутый JavaScript
T1	Командная оболочка CMD (Windows)
T2	Командная оболочка Bash (Linux)
T4	Регулярные выражения